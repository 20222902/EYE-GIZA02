from flask import Blueprint, request, jsonify
import requests
import socket
import nmap
from urllib.parse import urlparse
import concurrent.futures
import re
import dns.resolver

pentest_tools_bp = Blueprint("pentest_tools", __name__)

def is_valid_domain(domain):
    """التحقق من صحة النطاق"""
    domain_pattern = re.compile(
        r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-9])?$'
    )
    return domain_pattern.match(domain) is not None

def is_valid_ip(ip):
    """التحقق من صحة عنوان IP"""
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

# Helper function to check if a port is open
def check_port(host, port, timeout=1):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            return result == 0
    except Exception:
        return False

# Helper function for basic vulnerability scanning
def perform_basic_vulnerability_scan(url):
    parsed_url = urlparse(url)
    domain = parsed_url.netloc
    scheme = parsed_url.scheme

    vulnerabilities = []

    # Check for HTTPS (Insecure Protocol)
    if scheme == "http":
        vulnerabilities.append({
            "type": "Insecure Protocol",
            "description": "استخدام بروتوكول HTTP غير الآمن",
            "details": "الموقع لا يستخدم HTTPS",
            "recommendation": "تفعيل HTTPS وإعادة توجيه HTTP إلى HTTPS",
            "severity": "High"
        } )

    try:
        response = requests.get(url, timeout=5)
        headers = response.headers

        # Missing Security Headers
        security_headers = [
            ("X-Frame-Options", "حماية من Clickjacking", "إضافة هيدر X-Frame-Options للحماية"),
            ("X-XSS-Protection", "حماية من XSS", "إضافة هيدر X-XSS-Protection للحماية"),
            ("X-Content-Type-Options", "حماية من MIME sniffing", "إضافة هيدر X-Content-Type-Options للحماية"),
            ("Strict-Transport-Security", "إجبار استخدام HTTPS", "إضافة هيدر Strict-Transport-Security للحماية"),
            ("Content-Security-Policy", "سياسة أمان المحتوى", "إضافة هيدر Content-Security-Policy للحماية"),
        ]

        for header, description, recommendation in security_headers:
            if header not in headers:
                vulnerabilities.append({
                    "type": "Missing Security Header",
                    "description": f"هيدر الأمان مفقود: {header}",
                    "details": description,
                    "recommendation": recommendation,
                    "severity": "Medium"
                })

        # Information Disclosure (Server Header)
        if "Server" in headers:
            vulnerabilities.append({
                "type": "Information Disclosure",
                "description": "كشف معلومات الخادم",
                "details": f"Server: {headers["Server"]}",
                "recommendation": "إخفاء أو تقليل معلومات الخادم المكشوفة",
                "severity": "Low"
            })

    except requests.exceptions.RequestException as e:
        vulnerabilities.append({
            "type": "Connection Error",
            "description": "خطأ في الاتصال بالموقع",
            "details": str(e),
            "recommendation": "التحقق من توفر الموقع وصحة الرابط",
            "severity": "High"
        })

    severity_breakdown = {"High": 0, "Medium": 0, "Low": 0}
    for vuln in vulnerabilities:
        severity_breakdown[vuln["severity"]] += 1

    return {
        "target_url": url,
        "vulnerabilities_found": len(vulnerabilities),
        "severity_breakdown": severity_breakdown,
        "vulnerabilities": vulnerabilities
    }

# Helper function for subdomain enumeration (simplified)
def find_subdomains(domain):
    subdomains = []
    # In a real scenario, you'd use a wordlist and DNS queries
    # For this example, we'll just check a few common ones and the main domain
    common_subdomains = ["www", "mail", "ftp", "blog", "dev", "test", "admin", "portal"]
    checked_domains = [domain] + [f"{sub}.{domain}" for sub in common_subdomains]

    active_subdomains_count = 0

    for sub in checked_domains:
        try:
            ip_address = socket.gethostbyname(sub)
            subdomains.append({
                "subdomain": sub,
                "ip": ip_address,
                "status": "active"
            })
            active_subdomains_count += 1
        except socket.gaierror:
            subdomains.append({
                "subdomain": sub,
                "ip": None,
                "status": "inactive"
            })

    return {
        "target_domain": domain,
        "total_subdomains": len(subdomains),
        "active_subdomains": active_subdomains_count,
        "subdomains": subdomains
    }

# Helper function for port scanning (simplified using socket)
def scan_ports_socket(target_host, ports_to_scan):
    open_ports = []
    closed_ports = 0
    total_ports = len(ports_to_scan)

    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
        future_to_port = {executor.submit(check_port, target_host, port): port for port in ports_to_scan}
        for future in concurrent.futures.as_completed(future_to_port):
            port = future_to_port[future]
            try:
                if future.result():
                    open_ports.append({"port": port, "status": "open", "protocol": "TCP"})
                else:
                    closed_ports += 1
            except Exception:
                closed_ports += 1 # Treat errors as closed for simplicity

    return {
        "target_host": target_host,
        "total_ports": total_ports,
        "open_ports": len(open_ports),
        "closed_ports": closed_ports,
        "ports": open_ports
    }

# Helper function for URL Fuzzing (simplified)
def perform_url_fuzzing(base_url):
    parsed_url = urlparse(base_url)
    base_path = f"{parsed_url.scheme}://{parsed_url.netloc}"
    
    # Common paths/files to check
    wordlist = [
        "admin", "login", "panel", "dashboard", "config", ".env", ".git/config",
        "robots.txt", "sitemap.xml", "backup", "test", "dev", "phpinfo.php",
        "index.php", "index.html", "main.js", "app.js", "api", "v1", "v2"
    ]

    found_paths = []
    total_paths_checked = 0

    for path in wordlist:
        full_url = f"{base_path}/{path}"
        total_paths_checked += 1
        try:
            response = requests.get(full_url, timeout=3, allow_redirects=False)
            if response.status_code < 400:
                found_paths.append({
                    "path": full_url,
                    "status_code": response.status_code,
                    "content_type": response.headers.get("Content-Type"),
                    "size": len(response.content)
                })
        except requests.exceptions.RequestException:
            pass # Ignore connection errors for fuzzing

    return {
        "base_url": base_url,
        "total_paths": total_paths_checked,
        "found_paths": len(found_paths),
        "paths": found_paths
    }

# Helper function for Network Scanning (simplified using nmap if available, else placeholder)
def perform_network_scan(network_range):
    active_hosts = []
    total_ips = 0

    # Placeholder for nmap functionality
    # In a real scenario, you'd execute nmap command and parse its output
    # For simplicity, we'll simulate some active hosts
    
    # Example: if network_range is "192.168.1.0/24", we might simulate a few hosts
    # For now, we'll just return a dummy response
    
    # In a real implementation, you would use a library like python-nmap
    # or execute nmap via subprocess and parse its XML output.
    # For demonstration, we'll return a fixed set of active hosts.
    
    # This is a placeholder. A real network scan would involve:
    # 1. Parsing the network_range (e.g., "192.168.1.0/24")
    # 2. Using nmap to scan the range
    # 3. Parsing nmap's output to identify active hosts, their IPs, MACs, and vendors.

    # Dummy data for demonstration
    if network_range == "192.168.1.0/24":
        active_hosts = [
            {"ip": "192.168.1.1", "hostname": "router", "mac": "AA:BB:CC:DD:EE:F1", "vendor": "Cisco", "status": "up"},
            {"ip": "192.168.1.100", "hostname": "my-pc", "mac": "AA:BB:CC:DD:EE:F2", "vendor": "Dell", "status": "up"},
            {"ip": "192.168.1.101", "hostname": "server", "mac": "AA:BB:CC:DD:EE:F3", "vendor": "HP", "status": "up"},
        ]
        total_ips = 254 # For a /24 network
    else:
        active_hosts = [
            {"ip": "10.0.0.1", "hostname": "gateway", "mac": "00:11:22:33:44:55", "vendor": "Generic", "status": "up"}
        ]
        total_ips = 1 # Simplified for other ranges

    return {
        "target_network": network_range,
        "total_ips": total_ips,
        "active_hosts": len(active_hosts),
        "hosts": active_hosts
    }


@pentest_tools_bp.route("/vulnerability-scanner", methods=["POST"])
def vulnerability_scanner():
    data = request.get_json()
    url = data.get("url")

    if not url:
        return jsonify({"error": "URL is required"}), 400

    results = perform_basic_vulnerability_scan(url)
    return jsonify(results)

@pentest_tools_bp.route("/subdomain-finder", methods=["POST"])
def subdomain_finder():
    data = request.get_json()
    domain = data.get("domain")

    if not domain:
        return jsonify({"error": "Domain is required"}), 400

    results = find_subdomains(domain)
    return jsonify(results)

@pentest_tools_bp.route("/port-scanner", methods=["POST"])
def port_scanner():
    data = request.get_json()
    target = data.get("target")
    scan_type = data.get("scan_type", "quick")

    if not target:
        return jsonify({"error": "Target host/IP is required"}), 400

    ports_to_scan = []
    if scan_type == "quick":
        ports_to_scan = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 3389, 8080]
    elif scan_type == "common":
        # Top 1000 common ports (simplified list for example)
        ports_to_scan = list(range(1, 1025)) # First 1024 ports
    elif scan_type == "full":
        ports_to_scan = list(range(1, 65536))
    else:
        return jsonify({"error": "Invalid scan type"}), 400

    results = scan_ports_socket(target, ports_to_scan)
    return jsonify(results)

@pentest_tools_bp.route("/url-fuzzer", methods=["POST"])
def url_fuzzer():
    data = request.get_json()
    url = data.get("url")

    if not url:
        return jsonify({"error": "URL is required"}), 400

    results = perform_url_fuzzing(url)
    return jsonify(results)

@pentest_tools_bp.route("/network-scanner", methods=["POST"])
def network_scanner():
    data = request.get_json()
    network = data.get("network")

    if not network:
        return jsonify({"error": "Network range is required"}), 400

    results = perform_network_scan(network)
    return jsonify(results)
